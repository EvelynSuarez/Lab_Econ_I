yacasStart()
## Not run:
yacas(expression(Factor(x^2-1)))
exp1 <- expression(x^2 + 2 * x^2)
exp2 <- expression(2 * exp0)
exp3 <- expression(6 * pi * x)
exp4 <- expression((exp1 * (1 - sin(exp3))) / exp2)
print(yacas(exp4))
print(yacas("Version()")) # yacas version
file.copy(system.file("yacdir/R.ys", package = "Ryacas"), "~/.yacsrc")
Sys.setenv(YACAS_INVOKE_STRING = "yacas -pc --server 9734")
demo(Ryacas) # test it out
exp1 <- yacas(expression(Factor(x^2 - 1)))
Eval(exp1, list(x = 4))
exp1
exp1 <- yacas(expression(Factor(x^2 - 1)))
exp1
yacasStart()
library(Ryacas)
yacasStart()
demo(Ryacas) # test it out
return()
Eval(exp1, list(x = 4))
Eval(exp1, list(x = 4))
exp1
Eval(exp1, list(x=2))
exp1
exp2
x <- Sym("x")
x+4
x
x+4
y=x+4
y
y <- Sym("x")
x
y
x+y
z <- x+y
z
x+y
x+4
x
y
x*y
yacas(exp4)
exp4
z=Sym(x+y)
z
z=Sym(x)+Sym(y)
z
z
y
z <- Sym(x)+Sym(y)
z
z
z
yacas("n := (10 + 2) * 5")
z=yacas("n := (10 + 2) * 5")
z
x+x
z=x+y
z=Sym("ZZZZZZZZZ")
z
2*z
RR=z*z
RR
a <- 0.05
za.2 <- qnorm(1-a/2)
b <- 0.20
zb <- qnorm(1-b)
lambda12 <- -log(1/2)/12
lambda18 <- -log(1/2)/18
theta <- lambda18/lambda12
(d = round(4*(za.2+zb)^2/log(theta)^2))
Tf<-36
library(Ryacas)
n <- Sym("n")
Solve(n/2*(2-exp(-lambda12*Tf)-exp(-lambda18*Tf))==d , n)
n
ss=Solve(n/2*(2-exp(-lambda12*Tf)-exp(-lambda18*Tf))==d , n)
ss
ss
ss
soln <- Solve(n/2*(2-exp(-lambda12*Tf)-exp(-lambda18*Tf))==d , n)
X <- yacas(soln)$text
#Then, to extract the quotient, you can take advantage of the fact that many R language objects either are or can be coerced to lists.
X <- expression(list(n == 382/1.625))
res <- eval(X[[1]][[2]][[3]])
res
soln <- Solve(n/2*(2-exp(-lambda12*Tf)-exp(-lambda18*Tf))==d , n)
X <- yacas(soln)$text
X
soln <- Solve(n/2*(2-exp(-lambda12*Tf)-exp(-lambda18*Tf))==d , n)
X <- yacas(soln)$text
X<- expression(list(n == 382/1.625))
res <- eval(X[[1]][[2]][[3]])
res
yacas("A:={{a,b},{c,d}}")
A
yacas("A")
yacas("B:= (1+x)^2+k^3")
B
yacas("B")
## Not run:
yacas(expression(Factor(x^2-1)))
exp1 <- expression(x^2 + 2 * x^2)
exp2 <- expression(2 * exp0)
exp3 <- expression(6 * pi * x)
exp4 <- expression((exp1 * (1 - sin(exp3))) / exp2)
print(yacas(exp4))
print(yacas("Version()")) # yacas version
demo("Ryacas-Function")
library(Ryacas)
library(Ryacas)
# only need to do the file.copy command once
file.copy(system.file("yacdir/R.ys", package = "Ryacas"), "~/.yacsrc")
print(yacas(exp4))
install.packages("Ryacas", dep = TRUE)
library(Ryacas)
yacasInstall()
install.packages("Ryacas", dep = TRUE)
library(Ryacas)
yacasInstall()
runYacas()
getwd()
setwd("C://Users/Humberto Martínez/Documents/GitHub/Lab_Econ_I/H/R_drafts")
getwd()
# -------------------------------------------------------------------------
help.search("save")
5.3
5*-3
1+1
2-3
5*4
9/8
# -------------------------------------------------------------------------
# R puede ser usado para ejecutar operaciones como "calculadora"
1+1
2-3
5*4
9/8
5*4
9/8
1+1
2-3
25^3
25^(1/2)
sqr
sqr()
a = 52
b <- 52
c = "perrito"
d <- 55.5
e = TRUE
class(e)
# Para saber qué tipo de dato/variable es X objeto usamos:
class(e)
class(a)
class(c)
class(d)
a+a
b+a
d/a
e/a
g = TRUE # Boolean
g/a
a*g
h = FALSE
a*h
c*a
AporB=a*b
DentreA=d/a
worale=AporB/DentreA
a
b
c
d
e
f
g
h
worale
sqrt(worale)
c(5,4,6,4,6,6,6,3,321,321,321,321,6,0,0,0,0,0,0)
c(5,4,6,4,6,6,6,3,32121,6,0,0,0,0,0,0)
c(5,4,6,4,32121,6,0,0,0,0,0,0)
# Los vectores también se pueden guardar
b = c(98,987,987,987,987,7)
b
A = c(98,987,987,987,987,7,75.5)
Animalitos =  c("perro", "gato", "pollo")
Vbooleano = c(TRUE,FALSE)
A
Animalitos
Vbooleano
A = c(1,2,3)
B = c(5,6,7)
C = c(8,3,1)
D = A - B
E = D + A
D
E
A<E
A>E
F = A>E
F
A = matrix(c(1,2,3,4,5,6,7,8,9),3)
A
B = matrix(1,2,3,4)
B
C= matrix(1:9, byrow = TRUE, nrow = 3)
C
D = matrix(1:9, byrow = FALSE, nrow = 3)
D
A=D
E=A+D
E
F = A+A+A+A+A
F
G = 4A
G = 4*A
G = 2*A
G = 2*A
G
# Producto de matrices
H = A%*%A
H
I = A%*%D
I
# Producto de vectores
a = c(1,2,3)
b = c(2,3,4)
d = a%*%b
d
J = A%*%a
J
K = a%*%A
K
L = a%*%A%*%a
L
# Funciones sobre matrices
M = t(A)
M
N = t(t(A))
N
f = t(a)
f
g = t(f)
g
h = t(g)
h
# Identidad de tamaño k
I_15 = diag(15)
I_15
# Identidad de tamaño k
I_10 = diag(10)
I_10
O = solve(A)
O
a[1]
a[2]
A[1]
A[1,]
A[,1]
A
j = A[1,]
j
k = A[,1]
k
A[5]=5555
A[5]=5555
# Intentando inversa nuevamente
O = solve(A)
O
O[,1]=c(1,2,3)
O
P = cbind(A,O)
P
Q = cbing(A,a)
Q
Q = cbind(A,a)
Q
Q = cbind(A,a,a)
Q
Q = cbind(A,a,a,b)
Q
R = rbind(P,Q)
R
# sañldkfjñskldjfñaslkdjfñalskdjfñlaksdjfñlasdkjfñlasdkjfñasldkjfñasldkfjñasldkfjñaskldjfñasdlkjfñsadf
# añlksdjfñdjñasdkljfasñdlkfj#
ñaskldjfñasldkfjasñdlkf
# sañldkfjñskldjfñaslkdjfñalskdjfñlaksdjfñlasdkjfñlasdkjfñasldkjfñasldkfjñasldkfjñaskldjfñasdlkjfñsadf
# añlksdjfñdjñasdkljfasñdlkfj#
ñaskldjfñasldkfjasñdlkf
getwd()
setwd("C:\Users\Humberto Martínez\Documents\GitHub\Lab_Econ_I\Carreto_C")
# Verificar que el directorio se fijó correctamente
getwd()
1+1
2-3
5*4
9/8
25^3
25^(1/2)
2-3
5*4
9/8
25^3
25^(1/2)
abs(-5)
# sqrt(x)	da la raíz cuadrada
sqrt(144)
# round(x, digits=n) redondea el número x a n dígitos
round(3.141658354698436681864,5)
# log(x)  logaritmo natural del número x
log(36514364)
# exp(x) sencillamente es e^x
exp(6354)
a = 52 # Numeric, integers
b <- 52 # Numeric, integers
c = "perrito" # String or Character
d <- 55.5 # Numeric
g = TRUE # Boolean
h = FALSE
class(g)
class(a)
class(c)
class(d)
## llamandolas dan los valores que contienen
a
b
c
d
e
f # no ha sido definida
g
h
ñaskldjfñasldkfjasñdlkf = 654
ñaskldjfñasldkfjasñdlkf
## Numéricas con numéricas
a+a
b+a
d/a
g/a
# Numéricas con booleanas
a*g
a*h
## Numéricas con strings
c*a
# Además pueden ser creadas nuevas variables a partir de las existentes
AporB=a*b
DentreA=d/a
worale=AporB/DentreA
worale
# Así mismo, se les pueden aplicar todas las funciones antes mencionadas
sqrt(worale)
# Creando un vector
c(5,4,6,4,32121,6,0,0,0,0,0,0)
654654
45
15
c
c(4,5,6,4,)
c(4,5,6,4,5)
9878
# Los vectores también se pueden guardar
A = c(98,987,987,987,987,7,75.5)
A
Animalitos =  c("perro", "gato", "pollo")
Animalitos
Vbooleano = c(TRUE,FALSE)
A
Animalitos
Vbooleano
A = c(1,2,3)
B = c(5,6,7)
C = c(8,3,1)
D = A - B
E = D + A
D
E
A<E
A>E
F = A>E
F
A = matrix(c(1,2,3,4,5,6,7,8,9),3)
A
# matri
# matriz de unos, con dos filas y tres columnas
B = matrix(1,2,3)
B
B = matrix(5,2,3)
B
C= matrix(1:9, byrow = TRUE, nrow = 3)
C
# matriz identica a A
D = matrix(1:9, byrow = FALSE, nrow = 3)
D
# matriz identica a A
D = matrix(1:9, byrow = FALSE, nrow = 2)
#Suma
E=A+D
E
F = A+A+A+A+A
F
# Producto de escalar por una matriz
G = 2*A
G
H = A%*%A
H
I = A%*%D
I
a = c(1,2,3)
b = c(2,3,4)
d = a%*%b
d
# Producto de matrices por vectores
J = A%*%a
J
K = a%*%A
K
L = a%*%A%*%a
L
# Transpuesta
M = t(A)
M
N = t(t(A))
N
f = t(a)
f
h = t(g)
h
g = t(f)
g
h = t(g)
h
I_10 = diag(10)
I_10
a
# Elementos 1 y 2 del vector a
a[1]
a[2]
A
A[1]
# Fila 1
A[1,]
# Columna 1
A[,1]
j = A[1,]
j
k = A[,1]
k
O = solve(A)
O
A
# Cambiando el elemento 5 de la matriz A
A[5]=5555
A
# Intentando inversa nuevamente
O = solve(A)
O
O
# Cambiando la primera columna de O
O[,1]=c(1,2,3)
O
O
A
# Concatenar matrices horizontalmente
P = cbind(A,O)
P
a
b
Q = cbind(A,a,a,b)
Q
R = rbind(P,Q)
R
Ex1 = 0
Ex2 = -4
Ex3 = 1
Ey1 = -1
Ey2 = 4
varx1 = 1
varx2 = 4
varx3 = 2
vary1 = 1
vary2 = 9
covx1x2 = -1
covx1x3 = 0
covx1y1 = 0
covx1y2 = 1
covx2x3 = 2
covx2y1 = -1
covx2y2 = -3
covx3y1 = 0
covx3y2 = 3
covy1y2 = -2
EX = t(c(Ex1,Ex2,Ex3))
EX
EX = t(t(c(Ex1,Ex2,Ex3)))
EX
EX = matrix(c(Ex1,Ex2,Ex3),3)
EX
EX = matrix(c(Ex1,Ex2,Ex3),1)
EX
# EX = t(t(c(Ex1,Ex2,Ex3)))
EX = matrix(c(Ex1,Ex2,Ex3),3)
EX
varX = matrix(c(varx1,covx1x2,covx1x3,covx1x2,varx2,covx2x3,covx1x3,covx2x3,varx3),3)
varX
varY = matrix(c(vary1,covy1y2,covy1y2,vary2),2)
varY
